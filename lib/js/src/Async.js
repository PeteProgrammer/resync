// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List            = require("bs-platform/lib/js/list.js");
var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Js_exn          = require("bs-platform/lib/js/js_exn.js");
var Js_option       = require("bs-platform/lib/js/js_option.js");
var Caml_int32      = require("bs-platform/lib/js/caml_int32.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function $$return(x, param) {
  return Curry._1(param[0], x);
}

function toMilliseconds(param) {
  if (param.tag) {
    return Caml_int32.imul(param[0], 1000);
  } else {
    return param[0];
  }
}

var JsError = Caml_exceptions.create("Async.JsError");

var Timeout = Caml_exceptions.create("Async.Timeout");

function bind(f, x, param) {
  var errorCB = param[1];
  var successCb = param[0];
  return Curry._1(x, /* tuple */[
              (function (a) {
                  try {
                    return Curry._2(f, a, /* tuple */[
                                successCb,
                                errorCB
                              ]);
                  }
                  catch (raw_x){
                    return Curry._1(errorCB, Js_exn.internalToOCamlException(raw_x));
                  }
                }),
              errorCB
            ]);
}

function map(f, x, param) {
  var errorCb = param[1];
  var successCb = param[0];
  return Curry._1(x, /* tuple */[
              (function (a) {
                  var exit = 0;
                  var x;
                  try {
                    x = Curry._1(f, a);
                    exit = 1;
                  }
                  catch (raw_x){
                    return Curry._1(errorCb, Js_exn.internalToOCamlException(raw_x));
                  }
                  if (exit === 1) {
                    return Curry._1(successCb, x);
                  }
                  
                }),
              errorCb
            ]);
}

function tryCatch(f, x, param) {
  var errorCb = param[1];
  var successCb = param[0];
  return Curry._1(x, /* tuple */[
              successCb,
              (function (x) {
                  var match = Curry._1(f, x);
                  if (match) {
                    return Curry._1(successCb, match[0]);
                  } else {
                    return Curry._1(errorCb, x);
                  }
                })
            ]);
}

function iter(f) {
  return (function (param, param$1) {
      return map((function (x) {
                    Curry._1(f, x);
                    return x;
                  }), param, param$1);
    });
}

function from_js(jsAsync, param) {
  var errorCb = param[1];
  var successCb = param[0];
  return Curry._1(jsAsync, (function (err, s) {
                if (err !== null) {
                  return Curry._1(errorCb, [
                              JsError,
                              err
                            ]);
                } else {
                  return Curry._1(successCb, s);
                }
              }));
}

function once(x) {
  var resolution = [/* None */0];
  var waiting = [/* [] */0];
  var dispatch = function (result, param) {
    if (result.tag) {
      return Curry._1(param[1], result[0]);
    } else {
      return Curry._1(param[0], result[0]);
    }
  };
  var tryDispatch = function () {
    var match = resolution[0];
    if (match) {
      var x = match[0];
      var targets = waiting[0];
      waiting[0] = /* [] */0;
      return List.iter((function (callbacks) {
                    return dispatch(x, callbacks);
                  }), targets);
    } else {
      return /* () */0;
    }
  };
  Curry._1(x, /* tuple */[
        (function (s) {
            resolution[0] = /* Some */[/* Ok */Block.__(0, [s])];
            setTimeout(tryDispatch, 0);
            return /* () */0;
          }),
        (function (e) {
            resolution[0] = /* Some */[/* Error */Block.__(1, [e])];
            setTimeout(tryDispatch, 0);
            return /* () */0;
          })
      ]);
  return (function (callbacks) {
      var match = resolution[0];
      if (match) {
        return dispatch(match[0], callbacks);
      } else {
        waiting[0] = /* :: */[
          callbacks,
          waiting[0]
        ];
        return /* () */0;
      }
    });
}

function timeout(duration, x) {
  var resolved = [/* false */0];
  return (function (param) {
      var errorCb = param[1];
      var successCb = param[0];
      Curry._1(x, /* tuple */[
            (function (x) {
                if (resolved[0]) {
                  return 0;
                } else {
                  resolved[0] = /* true */1;
                  return Curry._1(successCb, x);
                }
              }),
            (function (e) {
                if (resolved[0]) {
                  return 0;
                } else {
                  resolved[0] = /* true */1;
                  return Curry._1(errorCb, e);
                }
              })
          ]);
      setTimeout((function () {
              if (resolved[0]) {
                return 0;
              } else {
                resolved[0] = /* true */1;
                return Curry._1(errorCb, Timeout);
              }
            }), toMilliseconds(duration));
      return /* () */0;
    });
}

function from_callback(fn, param) {
  return Curry._1(fn, param[0]);
}

function run(fe, f, x) {
  var fe$1 = Js_option.getWithDefault((function () {
          return /* () */0;
        }), fe);
  return Curry._1(x, /* tuple */[
              f,
              fe$1
            ]);
}

function runExn(fs, fe, x) {
  console.log("OBSOLETE FUNCTION CALL, use Async.run insteadn of Async.runExn");
  return Curry._1(x, /* tuple */[
              fs,
              fe
            ]);
}

exports.$$return       = $$return;
exports.toMilliseconds = toMilliseconds;
exports.JsError        = JsError;
exports.Timeout        = Timeout;
exports.bind           = bind;
exports.map            = map;
exports.tryCatch       = tryCatch;
exports.iter           = iter;
exports.from_js        = from_js;
exports.once           = once;
exports.timeout        = timeout;
exports.from_callback  = from_callback;
exports.run            = run;
exports.runExn         = runExn;
/* No side effect */
